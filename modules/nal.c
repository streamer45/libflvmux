#include "util.h"
#include "nal.h"

struct nal_parser {
  buffer_t *bufs[2];
  buffer_t *curr;
  size_t nframes;
  nal_parse_cb *cb;
  void *user;
};

static int checkNALStart(uint8_t *buf) {
  if (buf[0] == 0x00 && buf[1] == 0x00) {
    if (buf[2] == 0x01) return 3;
    else if (buf[2] == 0x00 && buf[3] == 0x01) return 4;
  }
  return 0;
}

static int checkNALEnd(uint8_t *buf) {
  if (buf[0] == 0x00 && buf[1] == 0x00) {
    if (buf[2] == 0x01 || buf[2] == 0x00) return 3;
  }
  return 0;
}

static int parse(nal_parser_t *np, buffer_t *in) {
  int res;
  bool inNAL = false;
  size_t pos = 0;
  size_t nalStart = 0;
  size_t nalStartHdrSz = 0;
  size_t nalEnd = 0;
  nal_frame_t frame;
  uint8_t *data;
  buffer_t *buf;

  buf = np->curr;
  res = buffer_copy(buf, in, buf->length, 0, in->length);

  if (res != 0) {
    ERROR("%d", res);
    return -2;
  }

  buf->length += in->length;
  data = buf->data;

  for (;;) {
    if (!inNAL) {
      if (buf->length < (pos + 4)) break;
      res = checkNALStart(&data[pos]);
      if (res > 0) {
        nalStartHdrSz = res;
        pos += res;
        nalStart = pos;
        inNAL = true;
        continue;
      }
    } else {
      if (buf->length < (pos + 3)) break;
      res = checkNALEnd(&data[pos]);
      if (res > 0) {
        nalEnd = pos;
        inNAL = false;
        ++np->nframes;
        memset(&frame, 0, sizeof(frame));
        frame.type = data[nalStart] & 0x1f;
        frame.long_sc = nalStartHdrSz == 4;
        frame.nalu.data = &data[nalStart - nalStartHdrSz];
        frame.nalu.size = buf->size - (nalStart - nalStartHdrSz);
        frame.nalu.length = nalEnd - nalStart + nalStartHdrSz;

        frame.buffer.data = &data[nalStart];
        frame.buffer.length = nalEnd - nalStart;
        frame.buffer.size = frame.buffer.length;

        np->cb(&frame, np->user);
        continue;
      }
    }
    ++pos;
  }

  if (buf->length > nalEnd) {
    buffer_t *new;
    if (buf == np->bufs[0]) new = np->bufs[1];
    else new = np->bufs[0];
    new->length = buf->length - nalEnd;
    res = buffer_copy(new, buf, 0, nalEnd, new->length);
    if (res != 0) {
      ERROR("%d", res);
      return -2;
    }
    np->curr = new;
  }

  return 0;
}

int nal_parser_flush(nal_parser_t *np) {
  int res;
  size_t nalStart = 0;
  size_t nalStartHdrSz = 0;
  size_t nalEnd = 0;
  nal_frame_t frame;
  uint8_t *data;
  buffer_t *buf;

  if (!np) return -1;
  buf = np->curr;
  if (!buf) return 0;

  data = buf->data;

  res = checkNALStart(data);

  if (res == 0) return 0;

  nalStartHdrSz = res;
  nalStart = res;
  nalEnd = buf->length;

  ++np->nframes;
  memset(&frame, 0, sizeof(frame));
  frame.type = data[nalStart] & 0x1f;
  frame.long_sc = nalStartHdrSz == 4;
  frame.nalu.data = &data[nalStart - nalStartHdrSz];
  frame.nalu.size = buf->size - (nalStart - nalStartHdrSz);
  frame.nalu.length = nalEnd - nalStart + nalStartHdrSz;

  frame.buffer.data = &data[nalStart];
  frame.buffer.length = nalEnd - nalStart;
  frame.buffer.size = frame.buffer.length;

  np->cb(&frame, np->user);

  return 0;
}

nal_parser_t *nal_parser_create(nal_parse_cb *cb, void *user) {
  nal_parser_t *np;
  if (!cb || !user) return NULL;
  np = calloc(1, sizeof(*np));
  if (!np) return NULL;
  np->bufs[0] = buffer_alloc(65536 * 4);
  if (!np->bufs[0]) {
    nal_parser_destroy(np);
    return NULL;
  }
  np->bufs[1] = buffer_alloc(65536 * 4);
  if (!np->bufs[1]) {
    nal_parser_destroy(np);
    return NULL;
  }
  np->curr = np->bufs[0];
  np->cb = cb;
  np->user = user;
  return np;
}

int nal_parser_destroy(nal_parser_t *np) {
  if (!np) return -1;
  if (np->bufs[0]) buffer_free(np->bufs[0]);
  if (np->bufs[1]) buffer_free(np->bufs[1]);
  free(np);
  return 0;
}

int nal_parser_parse(nal_parser_t *np, buffer_t *buf) {
  if (!np || !buf) return -1;
  return parse(np, buf);
}
